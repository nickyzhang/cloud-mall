spring.application.log.path = /opt/logs/cloud/${spring.application.name}/${spring.application.name}

#开启注册中心的保护机制，默认是开启,生产建议关闭，当检查所有服务达到一定比例的时候都没发送心跳，他会认为是网络故障
#则开启自我保护机制，把这些服务都不从服务注册表中移除
eureka.server.enable-self-preservation = false
# eureka.server.renewal-percent-threshold = 0.85
#注册中心路径，如果有多个eureka server，在这里需要配置其他eureka server的地址，用","进行区分，
#如"http://address:10000/eureka,http://address:10000/eureka"
eureka.client.service-url.defaultZone = http://cloud-shop-02:10000/eureka/
# 会向Eureka Server注册自己的信息
eureka.client.register-with-eureka = true
# 表明不会像Eureka Server获取注册信息
eureka.client.fetch-registry = true
eureka.instance.prefer-ip-address=true

################# Eureka 客户端优化 ######################
### 优化，默人30秒
eureka.client.registry-fetch-interval-seconds=3
# Eureka 客户端每隔30秒才发送一次心跳，优化为3秒
eureka.instance.lease-renewal-interval-in-seconds = 3

###################### 数据源配置 ######################
spring.datasource.type = com.zaxxer.hikari.HikariDataSource
spring.datasource.driver-class-name = com.mysql.jdbc.Driver
spring.datasource.username = root
spring.datasource.password = 123456
# 没有指定或者指定为utf8
spring.datasource.url = jdbc:mysql://192.168.3.24:3306/cloud_shop_order?useSSL=false&useUnicode=true&allowMultiQueries=true&characterEncoding=utf8

###################### Hikari连接池的配置 ######################
# 插入、删除、更新默认自动提交事务，mysql默认也是自动提交，但是spring会先设置为不自动提交，然后spring事务管理器会将数据库
# 连接对象的自动提交设置为false,直到完成事务提交，spring又给设置回去.
# MySQL的自动提交，是每条来自客户端的语句执行完后自动提交。如果是一组操作，使用begin或start transaction显式开启一个事
# 务，则需要显示的commit或rollback来结束事务。
spring.datasource.hikari.auto-commit = true
# 设置最大连接数
spring.datasource.hikari.maximum-pool-size = 65
# 连接关闭前最大空闲时间，超过这个时间就会关闭连接。设置这个目的是因为数据库一般都有默认的连接空闲时长，比如MySQL默认8小时，8小
# 时后，数据库连接关闭，但是数据库连接池是不知道的，所以需要在数据库连接池设置一个时间，到期就关闭连接(3分钟)
spring.datasource.hikari.idle-timeout = 180000
# 连接关闭前最小空闲连接数量，即连接池在空闲的时候也必须的连接数量，不能全部把连接关闭完
spring.datasource.hikari.minimum-idle = 2
# 客户端等待从连接池获取连接的等到时间()
spring.datasource.hikari.connection-timeout = 30000
# 这个连接最多存活3分钟，超过就会断开，如果为0，表示无限生命周期，最好和idle-timeout(连接超时时间设置一致)
spring.datasource.hikari.max-lifetime = 1800000
# 连接池名字
spring.datasource.hikari.pool-name = CloudShopHikari
#  set names utf8mb4; 命令会将 character_set_client、character_set_connection、character_set_results 3个会话字符集相关变量均设置为 utf8mb4，以保证写入或者读出的数据使用 utf8mb4 字符集进行解释
spring.datasource.hikari.connection-init-sql = set names utf8mb4

mybatis.mapper-locations=classpath:/mapper/*.xml
mybatis.type-aliases-package=com.cloud.model.order
#logging.level.com.cloud.mapper=debug

###################### 设置Redis连接 ######################
spring.redis.host = cloud-shop-01
spring.redis.port = 6379
spring.redis.password = 123abcABC
spring.redis.database = 0
#  连接池最大连接数,使用负值表示无限制
spring.redis.lettuce.pool.max-active = 8
# 连接池最大空闲数,使用负值表示无限制
spring.redis.lettuce.pool.max-idle = 8
# 连接池最大阻塞等待时间,使用负值表示无限制
spring.redis.lettuce.pool.max-wait = -1s
# 连接池最小空闲连接，只有设置为正值时候才有效
spring.redis.lettuce.pool.min-idle = 1
# redis超时时间
spring.redis.timeout=10s
# 会话存储介质
spring.session.store-type = redis
spring.session.redis.flush-mode = ON_SAVE

###################### 消息队列配置 ######################
spring.rabbitmq.host = cloud-shop-01
spring.rabbitmq.port = 5672
spring.rabbitmq.username = cloud
spring.rabbitmq.password = cloud
spring.rabbitmq.virtual-host = /
# 消息没有到exchange,则confirm回调，ack=false
# 消息到达exchange,则confirm回调,ack=true
spring.rabbitmq.publisher-confirms = true
# 即交换机根route key找不到对应的queue,则代理将这个消息返回给生产者
# 在允许消息丢失的场景下可以不用设置为true
spring.rabbitmq.publisher-returns = true
spring.rabbitmq.listener.simple.acknowledge-mode=manual
spring.rabbitmq.listener.simple.concurrency=1
spring.rabbitmq.listener.simple.max-concurrency=2
spring.rabbitmq.template.mandatory=true
spring.rabbitmq.template.retry.enabled=true
spring.rabbitmq.template.retry.multiplier=2
spring.rabbitmq.template.retry.initial-interval=1s
spring.rabbitmq.template.retry.max-interval=10000ms
spring.rabbitmq.template.retry.max-attempts=3

###################### 队列和交换机的设置 ######################
user.password.queue=user.update.password
user.password.exchange=user.update.password
user.password.key=user.update.password

###################### HttpClient配置 ######################
# 最大连接数
http.maxTotal = 100
#并发数
http.defaultMaxPerRoute = 32
#创建连接的最长时间
http.connectTimeout = 10000
#从连接池中获取到连接的最长时间
http.connectionRequestTimeout = 10000
#数据传输的最长时间
http.socketTimeout = 10000
#请求重试次数
http.retryCount = 3

###################### Ribbon超时配置 ######################
# 明确表示ribbon中使用eureka
ribbon.eureka.enabled=true
# 如果设置为true，那么其他的POST、PUT请求超时也可以重试，如果没做接口幂等性，那么就等着倒霉吧
# 如果设置为fase, 那么POST、PUT请求超时时不进行重试，但是GET请求需要重试
ribbon.OkToRetryOnAllOperations=false
# Spring Cloud生产优化，系统第一次被请求时候，每一个服务才会去初始化Ribbon的一些组件，需要耗费一定时间，所以很容易导致超时。
# 所以让每一个服务在启动的时候就去加载Ribbon相关的组件，避免第一次请求才去初始化，即立即加载。
ribbon.eager-load.enabled=true

# 处理请求超时时间或者服务调用请求超时时间，比如慢SQL或者故障导致服务调用超时
ribbon.ReadTimeout = 1000
# ribbon请求连接的超时时间，默认值2000, 即连接别的服务的请求超时时间
ribbon.ConnectTimeout = 1000
# 如果发生超时，比如商品详情服务调用库存服务，一般重试2次就可以了
# 对当前实例的重试次数，默认1
ribbon.MaxAutoRetries = 1
# 对切换实例的重试次数，默认1
ribbon.MaxAutoRetriesNextServer = 1

# hystrix设置
feign.hystrix.enabled=false
#hystrix.command.default.execution.timeout.enabled=true
#hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=30000

###################### Actuator 监控 ######################
management.endpoints.prometheus.enable=true
management.endpoints.web.exposure.include=*
# ["prometheus","info","health"]