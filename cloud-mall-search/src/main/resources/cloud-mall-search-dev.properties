spring.application.log.path = D:/logs/cloud/${spring.application.name}/${spring.application.name}

#开启注册中心的保护机制，默认是开启,生产建议关闭，当检查所有服务达到一定比例的时候都没发送心跳，他会认为是网络故障
#则开启自我保护机制，把这些服务都不从服务注册表中移除
eureka.server.enable-self-preservation = false
# eureka.server.renewal-percent-threshold = 0.85

eureka.client.register-with-eureka = true
eureka.client.fetch-registry = true

###################### Eureka 客户端优化 ######################
### 优化，默人30秒
eureka.client.registry-fetch-interval-seconds=3
# Eureka 客户端每隔30秒才发送一次心跳，优化为3秒
eureka.instance.lease-renewal-interval-in-seconds = 3
eureka.instance.prefer-ip-address=true

###################### 序列化 ######################
spring.jackson.serialization.fail-on-empty-beans=false
        

###################### Ribbon超时配置 ######################
# 明确表示ribbon中使用eureka
ribbon.eureka.enabled=true
# 如果设置为true，那么其他的POST、PUT请求超时也可以重试，如果没做接口幂等性，那么就等着倒霉吧
# 如果设置为fase, 那么POST、PUT请求超时时不进行重试，但是GET请求需要重试
ribbon.OkToRetryOnAllOperations=false
# Spring Cloud生产优化，系统第一次被请求时候，每一个服务才会去初始化Ribbon的一些组件，需要耗费一定时间，所以很容易导致超时。
# 所以让每一个服务在启动的时候就去加载Ribbon相关的组件，避免第一次请求才去初始化，即立即加载。
ribbon.eager-load.enabled=true

# 处理请求超时时间或者服务调用请求超时时间，比如慢SQL或者故障导致服务调用超时
ribbon.ReadTimeout = 1000
# ribbon请求连接的超时时间，默认值2000, 即连接别的服务的请求超时时间
ribbon.ConnectTimeout = 1000
# 如果发生超时，比如商品详情服务调用库存服务，一般重试2次就可以了
# 对当前实例的重试次数，默认1
ribbon.MaxAutoRetries = 1
# 对切换实例的重试次数，默认1
ribbon.MaxAutoRetriesNextServer = 1

# hystrix设置
feign.hystrix.enabled=false
#hystrix.command.default.execution.timeout.enabled=true
#hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=15000
#
##spring.cloud.sentinel.transport.dashboard=192.168.3.24:18080
##feign.sentinel.enabled=true

#elasticsearch.cluster-host=192.168.3.101,192.168.3.102,192.168.3.103
#elasticsearch.port=9200
#elasticsearch.cluster-name=cloudshop
#elasticsearch.scheme=http

elasticsearch.cluster-host=192.168.3.101
elasticsearch.port=9202
elasticsearch.cluster-name=cloudmall
elasticsearch.scheme=http